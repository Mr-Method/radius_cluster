#!perl
use strict;
use warnings 'FATAL' => 'all';
use v5.16;

use Abills::Base qw/_bp in_array load_pmodule/;
use Abills::Experimental;
use JSON qw/to_json from_json/;
use Maps;

our ($html, %lang, %conf, $admin, $db, @CABLECAT_EXTRA_COLORS, %permissions, @MODULES);

our Maps $Maps;

if ( $FORM{json} ) {
  _bp('', '', { SET_ARGS => { TO_CONSOLE => 1 } });
}

# DB module is available
exit if (
  form_purchase_module(
    {
      HEADER          => $user->{UID},
      MODULE          => 'Cablecat',
      REQUIRE_VERSION => 7.65,
    }
  )
);

# Using selects from Maps module
load_module('Maps', $html);

if ( !defined $Maps ) {
  $Maps = Maps->new($db, $admin, \%conf);
}

require Cablecat;
Cablecat->import();
our Cablecat $Cablecat = Cablecat->new($db, $admin, \%conf);
use Cablecat::Trace;
use Cablecat::Cable_blank;

require Equipment;
Equipment->import();
my $Equipment = Equipment->new($db, $admin, \%conf);

my %CONNECTION_TYPES = (
  1 => 'fiber',
  2 => 'equipment',
  3 => 'point_id',
  4 => 'splitter',
  5 => 'client',
  6 => 'cross'
);
if ( !in_array('Equipment', \@MODULES) ) {
  delete $CONNECTION_TYPES{2};
}

our @CABLECAT_COLORS = (
  'fcfefc', # white
  '04fefc', # sea
  'fcfe04', # yellow
  '048204', # green
  '840204', # brown
  'fc0204', # red
  'fc9a04', # orange
  'fc9acc', # pink
  '848284', # gray
  '0402fc', # blue
  '840284', # violet
  '040204', # black
  '04fe04', # yellowgreen
  '9cce04', # olive
  'fcfe9c', # beige
  'dbefdb', # natural
  'fde910', # lemon
  '9c3232', # cherry
);

$conf{CABLECAT_CLEAR_DEFAULT_COLORS} //= 0;
$conf{CABLECAT_COLOR_SCHEME_NUMBERS} //= 0;

# Allowing to add colors via config.pl
if ( @CABLECAT_EXTRA_COLORS ) {
  if ( $conf{CABLECAT_CLEAR_DEFAULT_COLORS} ) {
    @CABLECAT_COLORS = @CABLECAT_EXTRA_COLORS;
  }
  else {
    @CABLECAT_COLORS = (@CABLECAT_COLORS, @CABLECAT_EXTRA_COLORS);
  }
}

our %MAP_TYPE_ID = (
  'WELL'      => 1,
  'WIFI'      => 2,
  'BUILD'     => 3,
  'ROUTE'     => 4,
  'CONNECTER' => 5,
  'SPLITTER'  => 6,
  'CABLE'     => 7,
  'EQUIPMENT' => 8,
  'PILLAR'    => 9,
);

our %MAP_LAYER_ID = (
  CABLE => 10,
  WELL  => 11
);

if ( $permissions{3} ) {
  require Cablecat::Reports;
}

require Cablecat::ResultFormerFilters;
require Cablecat::Selects;
require Cablecat::Cable_blank;

our %CROSS_CROSS_TYPE = (
  1 => $lang{RACK_MOUNTABLE},
  2 => $lang{RETRACTABLE}
);

our %CROSS_PANEL_TYPE = (
  1 => $lang{SOLID_PANEL},
  2 => $lang{CHANGEABLE_PLANKS},
  3 => "$lang{SOLID_PANEL} SC DUPLEX"
);

our %CROSS_PORT_TYPE = (
  1 => 'SC',
  2 => 'SC DUPLEX',
  3 => 'FC',
  4 => 'ST',
  5 => 'LC (duplex)'
);

our %CROSS_POLISH_TYPE = (
  1 => 'UPC',
  2 => 'APC'
);

our %CROSS_FIBER_TYPE = (
  1 => '9/125',
  2 => '50/125',
  3 => '62,5/125',
  4 => 'OM3'
);

require Cablecat::Configure;
require Cablecat::Layers;
require Cablecat::Commutation;

#**********************************************************
=head2 cablecat_main()

=cut
#**********************************************************
sub cablecat_main {
  
  my $menu_button = sub {
    my ($lang_name, $function_name, $class) = @_;
    $html->element('li', $html->button($lang_name, "index=" . get_function_index($function_name)),
      {
        class => 'list-group-item ' . ($class ? ('list-group-item-' . $class) : '')
      }
    );
  };
  
  $html->tpl_show(
    _include('cablecat_main', 'Cablecat'),
    {
      GO_TO_MAP_BTN     => $menu_button->($lang{MAP}, 'maps_edit', 'success'),
      COLOR_SCHEMES_BTN => $menu_button->($lang{COLOR_SCHEMES}, 'cablecat_color_schemes'),
      CABLES_BTN        => $menu_button->($lang{CABLES}, 'cablecat_cables'),
      WELLS_BTN         => $menu_button->($lang{WELLS}, 'cablecat_wells'),
      SPLITTERS_BTN     => $menu_button->($lang{SPLITTERS}, 'cablecat_splitters'),
      CONNECTERS_BTN    => $menu_button->($lang{CONNECTERS}, 'cablecat_connecters'),
      COMMUTATIONS_BTN  => $menu_button->($lang{COMMUTATIONS}, 'cablecat_commutations'),
      CROSSES_BTN       => $menu_button->($lang{CROSSES}, 'cablecat_crosses')
    }
  );

  return 1;
}

#**********************************************************
=head2 cablecat_link_info()

=cut
#**********************************************************
sub cablecat_link_info {
  my ($element_type, $element_id, $fiber_num, $direction) = @FORM{'ELEMENT_TYPE', 'ELEMENT_ID', 'FIBER_NUM', 'DIRECTION'};
  
  if ( $FORM{renew} ) {
    my $res = _cablecat_get_link_info($element_id, $fiber_num, !$direction);
    print _cablecat_link_info_cell($element_id, $fiber_num, !$direction, $res);
    return 1;
  }
  elsif ( $FORM{add} && $FORM{TYPE} ) {
  
    my %CONNECTION_TYPE_VALUE = (
      1 => 'CABLE',
      2 => 'EQUIPMENT',
      3 => 'POINT',
      4 => 'SPLITTER',
      5 => 'UID',
      6 => 'CROSS',
    );
  
    my %ID_PARAM_NAME_FOR_TYPE = (
      1 => 'TO_CABLE_ID',
      2 => 'EQUIPMENT_ID',
      3 => 'POINT_ID',
      4 => 'SPLITTER_ID',
      5 => 'UID',
      6 => 'CROSS_ID',
    );
  
    my %FIBER_PARAM_NAME_FOR_TYPE = (
      1 => 'TO_FIBER',
      2 => 'EQUIPMENT_PORT',
      3 => 'empty',
      4 => 'SPLITTER_PORT',
      5 => 'SERVICE_ID',
      6 => 'CROSS_PORT',
    );
  
    my %cable_params = (
      TYPE      => $element_type,
      ID        => $element_id,
      FIBER_NUM => $fiber_num
    );
  
    my $other_element_id_param_name = $ID_PARAM_NAME_FOR_TYPE{$FORM{TYPE}};
    my $other_fiber_param_name = $FIBER_PARAM_NAME_FOR_TYPE{$FORM{TYPE}} || 'empty';
  
    if (!$other_element_id_param_name){
      $html->message('err', $lang{ERROR}, "wrong params given");
      return 0;
    }
    
    my %other_element_params = (
      TYPE      => $CONNECTION_TYPE_VALUE{$FORM{TYPE}},
      ID        => $FORM{$other_element_id_param_name},
      FIBER_NUM => $FORM{$other_fiber_param_name} || q{}
    );
  
    $Cablecat->links_add({
      ELEMENT_1_TYPE => ($direction) ? $other_element_params{TYPE} : $cable_params{TYPE},
      ELEMENT_1_ID   => ($direction) ? $other_element_params{ID} : $cable_params{ID},
      FIBER_NUM_1    => ($direction) ? $other_element_params{FIBER_NUM} : $cable_params{FIBER_NUM},
      ELEMENT_2_TYPE => (!$direction) ? $other_element_params{TYPE} : $cable_params{TYPE},
      ELEMENT_2_ID   => (!$direction) ? $other_element_params{ID} : $cable_params{ID},
      FIBER_NUM_2    => (!$direction) ? $other_element_params{FIBER_NUM} : $cable_params{FIBER_NUM},
      COMMUTATION_ID => $FORM{TO_COMMUTATION},
    });

    show_result($Cablecat, "$lang{FIBER} $lang{LINK} $lang{ADDED}", '', { ID => "LINK_ADDED" });
    return 1;
  }
  elsif ( $FORM{del} && $element_id && $fiber_num && defined $direction ) {
    # Deleting is normally done via id, so passing 'undef' to use exended params del
    my $element_position = (!$direction ? 2 : 1);
    $Cablecat->links_del(undef, {
        "element_$element_position\_type" => $element_type,
        "element_$element_position\_id"   => $element_id,
        "fiber_num_$element_position"     => $fiber_num
      });
    show_result($Cablecat, "$lang{FIBER} $lang{LINK} $lang{DELETED}", '', { ID => "LINK_DELETED" });
    return 1;
  }
  elsif ( $FORM{request} && $FORM{TYPE} && exists $CONNECTION_TYPES{$FORM{TYPE}} ) {
    load_pmodule('JSON');
    
    #*****************************************************
    # sub_make_select_options - form select options from list
    #
    #*****************************************************
    my $sub_make_select_options = sub {
      my ($list, $key_name, $value_name ) = @_;
      
      my @options = ({ name => '--', value => '--' });
      
      push (@options, map {{ name => $_->{$key_name}, value => $_->{$value_name} }} @{$list});
      
      # Return
      \@options;
    };
    
    #*****************************************************
    # select_next_option - return JSON select to extend search form
    #
    #*****************************************************
    my $select_next_option = sub {
      my ($name, $label, $list, $attr) = @_;
      my %res = ();
      
      if ( !$list || ref $list ne 'ARRAY' || !scalar @{$list} ) {
        $res{text} = qq{ "$label : $lang{NO_DATA}" };
      }
      else {
        if ( $attr->{has_next} ) {
          $attr->{next} = { load => 1 };
        }
        
        %res = (select => JSON::to_json({
            name    => $name,
            label   => $label,
            options => $sub_make_select_options->($list, $attr->{name_key} || 'name', $attr->{id_key} || 'id'),
            %{ $attr ? $attr : {} }
          })
        )
      }
      
      push @{$html->{JSON_OUTPUT}}, \%res;
      1;
    };
    
    #*****************************************************
    # input_next_option - return JSON input field to extend search form
    #
    #*****************************************************
#    my $input_next_option = sub {
#      my ($name, $label, $attr) = @_;
#
#      my %res = (
#        input => to_json({
#          name  => $name,
#          label => $label,
#          %{ $attr ? $attr : {} }
#        })
#      );
#
#      push @{$html->{JSON_OUTPUT}}, \%res;
#      1;
#    };
#
    my $type = $CONNECTION_TYPES{$FORM{TYPE}};
    
    my $commutation_select = sub {
      # Get all commutations where this element is involved
      
      my $commutations_list = $Cablecat->get_commutations_for_element($element_type, $element_id);
      _error_show($Cablecat);
      
      my @commutations = map {
        {
          name => "$lang{COMMUTATION}#$_",
          id   => $_
        }
      } @{$commutations_list};
  
      return $select_next_option->('TO_COMMUTATION', $lang{COMMUTATION}, \@commutations, { has_next => 1 });
    };
  
    if ( !$FORM{TO_COMMUTATION} ) {
      return $commutation_select->();
    }
    
    if ( $type eq 'fiber' ) {
      
      # Cable
      if ( !$FORM{TO_CABLE_ID} ) {
        
        my $commutations = $Cablecat->commutations_list({
          ID        => $FORM{TO_COMMUTATION},
          CABLE_IDS => '_SHOW',
          CABLES    => '_SHOW',
          PAGE_ROWS => 10000
        });
        _error_show($Cablecat);
        
        my %unique_cables = ();
        foreach ( @{$commutations} ) {
          my @cable_ids = split(',\s?', $_->{cable_ids});
          my @cable_names = split(',\s?', $_->{cables});
          
          for( 0 .. $#cable_ids ) {
            $unique_cables{$cable_ids[$_]} = $cable_names[$_];
          }
        }
        # Delete this cable from list
        delete $unique_cables{$element_id};
        
        my @unique_list = map {
          {
            id   => $_,
            name => $unique_cables{$_}
          }
        } sort keys (%unique_cables);
        
        return $select_next_option->('TO_CABLE_ID', $lang{CABLE}, \@unique_list, { has_next => 1 });
      }
      elsif ( !$FORM{TO_FIBER} ) {
        my $cable_id_to_connect = $FORM{TO_CABLE_ID};
        
        my $cable_info = $Cablecat->cables_info($cable_id_to_connect, {
            FIBERS_COUNT     => '_SHOW',
            SHOW_ALL_COLUMNS => 0,
            COLS_UPPER       => 0
          });
        
        my $fibers_list = [ map {{ id => $_, name => $_ }} (1 .. $cable_info->{fibers_count}) ];
        
        return $select_next_option->('TO_FIBER', "$lang{FIBER} #", $fibers_list);
      }
    }
    elsif ( $type eq 'equipment' ) {
      
      # Equipment_select
      if ( !$FORM{EQUIPMENT_ID} ) {
        my $equipment_list = $Equipment->_list({ COLS_NAME => 1, NAS_NAME => '_SHOW', PAGE_ROWS => 10000 });
        
        return $select_next_option->('EQUIPMENT_ID', $lang{EQUIPMENT}, $equipment_list, {
            name_key => 'nas_name',
            id_key   => 'nas_id',
            has_next => 1
          });
      }
      elsif ( $FORM{EQUIPMENT_ID} ) {
        my $equipment_info = $Equipment->_info($FORM{EQUIPMENT_ID});
        my $ports_count = $equipment_info->{PORTS};
        
        my @options_list = map {
          { id => $_, name => $_ }
        } (1 ... $ports_count);
        
        return $select_next_option->('EQUIPMENT_PORT', $lang{PORT}, \@options_list);
      }
    }
    elsif ( $type eq 'point_id' ) {
      if ( !$FORM{POINT_TYPE_ID} ) {
        my $point_types_list = $Maps->point_types_list({
          ID         => '_SHOW',
          NAME       => '_SHOW',
          PAGE_ROWS  => 10000,
          COLS_UPPER => 0
        });
        _error_show($Maps);
        
        return $select_next_option->('POINT_TYPE_ID', $lang{BY_TYPE}, translate_list($point_types_list),
          { has_next => 1 });
      }
      # point select
      elsif ( !$FORM{POINT_ID} ) {
        my $points_for_type_list = $Maps->points_list({
          ID         => '_SHOW',
          NAME       => '_SHOW',
          TYPE_ID    => $FORM{POINT_TYPE_ID},
          PAGE_ROWS  => 10000,
          COLS_UPPER => 0
        });
        _error_show($Maps);
        
        # Port select
        return $select_next_option->('POINT_ID', $lang{OBJECT}, $points_for_type_list);
      }
    }
    elsif ( $type eq 'splitter' ) {
      if ( !$FORM{WELL_ID} ) {
        my $wells_list = $Cablecat->wells_list({
          ID         => '_SHOW',
          NAME       => '_SHOW',
          COLS_UPPER => 0,
          PAGE_ROWS  => 10000
        });
        _error_show($Cablecat);
        
        # connecter select
        return $select_next_option->('WELL_ID', $lang{WELL}, $wells_list, { has_next => 1 });
      }
      elsif ( !$FORM{SPLITTER_ID} ) {
        my $splitters_list = $Cablecat->splitters_list({
          ID         => '_SHOW',
          TYPE       => '_SHOW',
          WELL_ID    => $FORM{WELL_ID},
          COLS_UPPER => 0,
          PAGE_ROWS  => 10000
        });
        _error_show($Cablecat);
        
        # Generating name
        @{$splitters_list} = map {$_->{name} = $_->{type} . '_' . $_->{id};
          $_} @{$splitters_list};
        
        # connecter select
        return $select_next_option->('SPLITTER_ID', $lang{SPLITTER}, $splitters_list, { has_next => 1 });
      }
      if ( !$FORM{SPLITTER_DIRECTION} ) {
        
        my @splitter_directions = (
          { name => $lang{ENTER}, id => 1 },
          { name => $lang{OUTER}, id => 2 }
        );
        
        # splitter direction select
        return $select_next_option->('SPLITTER_DIRECTION', $lang{DIRECTION}, \@splitter_directions, { has_next => 1 });
      }
      if ( !$FORM{SPLITTER_PORT} ) {
        my $splitter_info = $Cablecat->splitters_info($FORM{SPLITTER_ID});
        
        my @options = ();
        if ($FORM{SPLITTER_DIRECTION} == 1){
          for (my $i = 1; $i <= $splitter_info->{fibers_out}; $i++){
            push (@options, { id => $splitter_info->{fibers_in} + $i, name => $i });
          }
        }
        else {
          for (my $i = 1; $i <= $splitter_info->{fibers_in}; $i++){
            push (@options, { id => $i, name => $i });
          }
        }

        return $select_next_option->('SPLITTER_PORT', $lang{PORT}, \@options);
      }
    }
    elsif ( $type eq 'client' ) {
      
      my %search_types = (
        1 => 'ADDRESS',
        2 => 'TAGS',
        3 => 'GROUP'
      );
      
      if ( !in_array('Tags', \@MODULES) ) {
        delete $search_types{2};
      }
      
      my %SEARCH_PARAMS = ();
      
      if ( !$FORM{SEARCH_BY} ) {
        
        my @search_options = map {
          {
            id   => $_,
            name => _translate('$lang{' . $search_types{$_} . '}')
          }
        } sort keys %search_types;
        
        # search type select
        return $select_next_option->('SEARCH_BY', $lang{SEARCH}, \@search_options, { has_next => 1 });
      }
      elsif ( $FORM{SEARCH_BY} == 1 ) {
        # Address
        require Address;
        my $Address = Address->new($db, $admin, \%conf);
        
        # District select
        if ( !$FORM{DISTRICT_ID} ) {
          my $districts_list = $Address->district_list({
            COLS_NAME  => 1,
            COLS_UPPER => 0,
            PAGE_ROWS  => 10000
          });
          
          return $select_next_option->('DISTRICT_ID', $lang{DISTRICT}, $districts_list, { has_next => 1 });
        }
        elsif ( !$FORM{STREET_ID} ) {
          my $streets_list = $Address->street_list({
            DISTRICT_ID => $FORM{DISTRICT_ID},
            STREET_NAME => '_SHOW',
            COLS_NAME   => 1,
            COLS_UPPER  => 0,
            PAGE_ROWS   => 10000
          });
          
          return $select_next_option->('STREET_ID', $lang{STREET}, $streets_list, {
              name_key => 'street_name',
              id_key   => 'street_id',
              has_next => 1
            });
        }
        elsif ( !$FORM{LOCATION_ID} ) {
          my $builds_list = $Address->build_list({
            STREET_ID  => $FORM{STREET_ID},
            COLS_NAME  => 1,
            COLS_UPPER => 0,
            PAGE_ROWS  => 10000
          });
          
          return $select_next_option->('LOCATION_ID', $lang{BUILD}, $builds_list,
            { name_key => 'number', has_next => 1 });
        }
        else {
          $SEARCH_PARAMS{LOCATION_ID} = $FORM{LOCATION_ID};
        }
      }
      elsif ( $FORM{SEARCH_BY} == 2 ) {
        # Tags
        require Tags;
        my $Tags = Tags->new($db, $admin, \%conf);
        if ( !$FORM{TAG_ID} ) {
          
          # Tag select
          my $tags_list = $Tags->list({
            NAME       => '_SHOW',
            ID         => '_SHOW',
            COLS_NAME  => 1,
            COLS_UPPER => 0,
            PAGE_ROWS  => 10000
          });
          
          return $select_next_option->('TAG_ID', $lang{TAGS}, $tags_list, { has_next => 1 });
        }
        
        # Tags uses his own user search logic
        my $users_list = $Tags->tags_list({
          TAG_ID    => $FORM{TAG_ID},
          LOGIN     => '_SHOW',
          COLS_NAME => 1,
          PAGE_ROWS => 10000,
        });
        
        return $select_next_option->('UID', $lang{USER}, $users_list, {
            name_key => 'login',
            id_key   => 'uid'
          });
      }
      elsif ( $FORM{SEARCH_BY} == 3 ) {# Group
        if ( !$FORM{GROUP_ID} ) {
          my $groups_list = $users->groups_list({
            NAME      => '_SHOW',
            ID        => '_SHOW',
            COLS_NAME => 1,
            PAGE_ROWS => 10000
          });
          
          # Group select
          return $select_next_option->('GROUP_ID', $lang{GROUP}, $groups_list, {
              id_key   => 'gid',
              has_next => 1
            });
        }
        else {
          $SEARCH_PARAMS{GID} = $FORM{GROUP_ID};
        }
      }
      
      if ( $FORM{UID} ){
        my $select_options = _cablecat_get_user_services_select($FORM{UID}, { RETURN_LIST => 1 });
        return $select_next_option->('SERVICE_ID', $lang{SERVICE}, $select_options, {
            has_next => 0
          });
      }
      else {
        # Search by selected type
        my $users_list = $users->list({
          UID       => '_SHOW',
          LOGIN     => '_SHOW',
          %SEARCH_PARAMS,
          COLS_NAME => 1,
          PAGE_ROWS => 10000
        });
        
        return $select_next_option->('UID', $lang{USER}, $users_list, {
            name_key => 'login',
            id_key   => 'uid',
            has_next => 1
        });
      }
      return 0;
    }
    elsif ( $type eq 'cross' ) {
      if ( !$FORM{WELL_ID} ) {
        my $wells_list = $Cablecat->wells_list({
          ID         => '_SHOW',
          NAME       => '_SHOW',
          COLS_UPPER => 0,
          PAGE_ROWS  => 10000
        });
        _error_show($Cablecat);
        
        # connecter select
        return $select_next_option->('WELL_ID', $lang{WELL}, $wells_list, { has_next => 1 });
      }
      elsif ( !$FORM{CROSS_ID} ) {
        my $crosses_list = $Cablecat->crosses_list({
          ID         => '_SHOW',
          NAME       => '_SHOW',
          WELL_ID    => $FORM{WELL_ID},
          COLS_UPPER => 0,
          PAGE_ROWS  => 10000
        });
        _error_show($Cablecat);
        
        # connecter select
        return $select_next_option->('CROSS_ID', $lang{CROSS}, $crosses_list, { has_next => 1 });
      }
      elsif ( !$FORM{CROSS_PORT} ) {
        my $selected_cross = $Cablecat->crosses_info($FORM{CROSS_ID}, { COLS_UPPER => 0 });
        my $ports_count = $selected_cross->{ports_count};
        my @ports_list = map {{ id => $_, name => $_ }} (1 .. $ports_count);
        
        #        _bp('', \@ports_list);
        
        return $select_next_option->('CROSS_PORT', $lang{PORT}, \@ports_list);
      }
    }
  }
  
  push @{$html->{JSON_OUTPUT}},
    {
      text => $lang{ERROR}
    };
  
  return 1;
}

#**********************************************************
=head2 _cablecat_cable_links_table()

=cut
#**********************************************************
sub _cablecat_cable_links_table {
  my ($cable_id) = @_;
  
  my %cable = ();
  # Allow to pass DB row
  if ( !ref $cable_id ) {
    my $cable_info = $Cablecat->cables_info($cable_id);
    return 0 if ( _error_show($Cablecat) );
    
    %cable = %{$cable_info};
  }
  else {
    %cable = %{$cable_id};
    $cable_id = $cable{id};
  }
  
  return '' unless ( $cable{fibers_count} && $cable{modules_count} );
  my $fibers_count = $cable{fibers_count};
  my $modules_count = $cable{modules_count};
  my $fibers_in_module = int($fibers_count / $modules_count);
  
  return '' unless ( $cable{fibers_colors} && $cable{modules_colors} );
  my @colors = split(',', $cable{fibers_colors});
  my @module_colors = split(',', $cable{modules_colors});
  
  # Get commutations for this cable
  my $commutations = $Cablecat->commutations_list({
    CABLE_IDS        => $cable_id,
    SHOW_ALL_COLUMNS => 1,
    PAGE_ROWS        => 10000
  });
  
  return '' if ( _error_show($Cablecat) || !$commutations || !(ref($commutations) eq 'ARRAY') || !scalar(@{$commutations}) );
  
  my $links = $Cablecat->links_for_element_list('CABLE', $cable_id, {
      ID             => '_SHOW',
      COMMUTATION_ID => '_SHOW',
      FIBER_NUM_1    => '_SHOW',
      FIBER_NUM_2    => '_SHOW',
      ELEMENT_1_SIDE => '_SHOW',
      ELEMENT_2_SIDE => '_SHOW',
      ATTENUATION    => '_SHOW',
      COMMENTS       => '_SHOW',
      PAGE_ROWS      => 10000
    });
  return 0 if ( _error_show($Cablecat) );
  
  my %left_link_info = ();
  my %right_link_info = ();
  foreach my $link (@{$links}){
    # TODO: check 3 links for same fiber side
    
    if (defined $link->{is_left} && $link->{is_left}){
      if (defined $left_link_info{$link->{fiber_num_1}}){
        # TODO: change direction in DB
        $right_link_info{$link->{fiber_num_1}} = $link;
      }
      else {
        $left_link_info{$link->{fiber_num_1}} = $link;
      }
    }
    else {
      if (defined $right_link_info{$link->{fiber_num_2}}){
        $left_link_info{$link->{fiber_num_2}} = $link;
      }
      else {
        $right_link_info{$link->{fiber_num_2}} = $link;
      }
    }
  }

  my $sub_get_info_for_fiber = sub {
    my ($f_num, $is_right) = @_;
    my $res = '';
    
    my $links_hash = ($is_right) ? \%right_link_info : \%left_link_info;

    if (!exists $links_hash->{$f_num}){
      return $html->button('', '', {
          class     => 'add',
          ICON      => 'glyphicon glyphicon-plus',
          BUTTON    => 1,
          SKIP_HREF => 1,
          ex_params => "onClick='addLinkInfo(\"CABLE\", $cable_id, $f_num, $is_right)'"
        })
    }
    else {
      # FIXME: Here "is_right" is wrong(opposite) (should look trough all code with hashes)
#      $res = _cablecat_external_link_info($cable_id, $f_num, $is_right, $links_hash->{$f_num});
      $res = _cablecat_get_link_info('CABLE', $cable_id, $f_num, !$is_right, $links_hash->{$f_num});
    }
    return _cablecat_link_info_cell('CABLE', $cable_id, $f_num, !$is_right, $res);
  };
  
  # Table will consist of two columns, and $fibers_num rows
  my @rows = ();
  foreach my $fiber_num ( 0 .. $fibers_count - 1 ) {
    my $module_num = int($fiber_num / $fibers_in_module);
    
    my $fiber_color = $colors[$fiber_num % $fibers_in_module] || "";
    my $module_color = $module_colors[ $module_num ];
    #
    my $info_left = $sub_get_info_for_fiber->(int ($fiber_num + 1), 1);
    my $info_right = $sub_get_info_for_fiber->(int ($fiber_num + 1), 0);
    
    push (@rows,
      [
        $html->element('div', '&nbsp;', {
            style => 'background-color : #' . $module_color,
            class => 'colored-block module-color'
          })
          . $html->element('div', '&nbsp;', {
            style => 'background-color : #' . $fiber_color,
            class => 'colored-block fiber-color'
          })
          . ($module_num + 1) . ':' . ($fiber_num + 1),
        $info_left, $info_right
      ]
    );
  }
  
  return _cablecat_links_table('CABLE', $cable_id, {
      caption     => "$lang{INFO} : $cable{name}",
      EXPORT      => 1,
      title_plain => [ "$lang{MODULE}:$lang{FIBER}", $lang{ENTER}, $lang{OUTER} ],
      ID          => 'CABLECAT_CABLE_LINKS_ID',
      rows        => \@rows
    } );
}

#**********************************************************
=head2 _cablecat_splitter_links_table()

=cut
#**********************************************************
sub _cablecat_splitter_links_table {
  my ($splitter_id) = @_;
  
  my $splitter = $Cablecat->splitters_info($splitter_id);
  
  return '' unless ( $splitter->{fibers_in} && $splitter->{fibers_out} );
  
  # Get commutations for this splitter
  my $commutations = $Cablecat->get_commutations_for_element('SPLITTER', $splitter_id);
  return '' if ( _error_show($Cablecat) || !scalar(@{$commutations}) );
  
  my $links = $Cablecat->links_for_element_list('SPLITTER', $splitter_id, {
      ID             => '_SHOW',
      COMMUTATION_ID => '_SHOW',
      FIBER_NUM_1    => '_SHOW',
      FIBER_NUM_2    => '_SHOW',
      ELEMENT_1_SIDE => '_SHOW',
      ELEMENT_2_SIDE => '_SHOW',
      ATTENUATION    => '_SHOW',
      COMMENTS       => '_SHOW',
      SORT           => 'fiber_num_1',
      PAGE_ROWS      => 10000
    });
  return 0 if ( _error_show($Cablecat) );
  
  my %left_link_info = ();
  my %right_link_info = ();
  foreach my $link (@{$links}){
    
    # All fibers less than fibers_in are inputs
    # All fibers greater than fibers_out are outputs
    
    if ($link->{fiber_num_1} > $splitter->{fibers_in}){
      if (defined $left_link_info{$link->{fiber_num_1}}){
        # TODO: change direction in DB
        $right_link_info{$link->{fiber_num_1}} = $link;
      }
      else {
        $left_link_info{$link->{fiber_num_1}} = $link;
      }
    }
    else {
      if (defined $right_link_info{$link->{fiber_num_2}}){
        $left_link_info{$link->{fiber_num_2}} = $link;
      }
      else {
        $right_link_info{$link->{fiber_num_2}} = $link;
      }
    }
  }
  
  my $sub_get_info_for_fiber = sub {
    my ($f_num, $is_right) = @_;
    my $res = '';

    my $links_hash = ($is_right) ? \%right_link_info : \%left_link_info;

    if (!exists $links_hash->{$f_num}){
      return $html->button('', '', {
          class     => 'add',
          ICON      => 'glyphicon glyphicon-plus',
          BUTTON    => 1,
          SKIP_HREF => 1,
          ex_params => "onClick='addLinkInfo(\"SPLITTER\", $splitter_id, $f_num, $is_right)'"
        })
    }
    else {
      # FIXME: Here "is_right" is wrong(opposite) (should look trough all code with hashes)
      #      $res = _cablecat_external_link_info($cable_id, $f_num, $is_right, $links_hash->{$f_num});
      $res = _cablecat_get_link_info('SPLITTER', $splitter_id, $f_num, !$is_right, $links_hash->{$f_num});
    }
    return _cablecat_link_info_cell('SPLITTER', $splitter_id, $f_num, !$is_right, $res);
  };
#
  # Table will consist of two columns, and $fibers_num rows
  my @rows = ();
  my $max_fibers_side = ($splitter->{fibers_in} > $splitter->{fibers_out})
                          ? $splitter->{fibers_in}
                          : $splitter->{fibers_out};
  
  foreach my $fiber_num ( 0 .. $max_fibers_side ) {
    
    my $info_left = '';
    my $info_right = '';
    if ($fiber_num < $splitter->{fibers_in}){
      $info_left = $sub_get_info_for_fiber->(int ($fiber_num + 1), 1);
    }
    else {
      $info_right = $sub_get_info_for_fiber->(int ($fiber_num + 1), 0);
    }

    push (@rows,
      [
        $fiber_num,
        $info_left,
        $info_right
      ]
    );
  }

  return _cablecat_links_table('SPLITTER', $splitter_id, {
      caption     => "$lang{INFO} : $splitter->{type}#$splitter->{id}",
      EXPORT      => 1,
      title_plain => [ $lang{FIBER}, $lang{ENTER}, $lang{OUTER} ],
      ID          => 'CABLECAT_CABLE_LINKS_ID',
      rows        => \@rows
    });
}

#**********************************************************
=head2 _cablecat_links_table($table_attr)

=cut
#**********************************************************
sub _cablecat_links_table {
  my ($element_type, $element_id, $table_attr) = @_;
  
  my Abills::HTML $table = $html->table($table_attr);
  
  # SHOULD BE THE SAME IN cablecat_link_info
  my %connection_type_lang = (
    1 => 'FIBER',
    2 => 'PORT',
    3 => 'OBJECT',
    4 => 'SPLITTER',
    5 => 'USER',
    6 => 'CROSS',
  );
  
  my @connection_type_modal_select_options = ({ name => '--', value => '--' }, map {
      {
        name  => _translate('$lang{' . $connection_type_lang{$_} . '}'),
        value => $_
      };
    } sort keys %CONNECTION_TYPES
  );
  
  $html->tpl_show(_include('cablecat_links_info', 'Cablecat'),
    {
      LINK_TYPE_OPTIONS => JSON::to_json(\@connection_type_modal_select_options),
      ELEMENT_TYPE        => $element_type,
      ELEMENT_ID          => $element_id
    }
  );
  
  return $table->show({ OUTPUT2RETURN => 1 });
}

#**********************************************************
=head2 cablecat_nas_trace_connection_form()

=cut
#**********************************************************
sub cablecat_nas_trace_connection_form {

  if (my $module_load_error = load_pmodule("JSON", { SHOW_RETURN => 1 })) {
    print $module_load_error;
    return 0;
  }

  my Cablecat::Trace $Tracer = Cablecat::Trace->new($db, $admin, \%conf);

  my %TEMPLATE_PARAMS = ();

  if ($FORM{action}) {

    # Check required params
    if (!$FORM{NAS_ID} || !$FORM{ENDPOINT_NAS_ID} ) {
      $html->message('err', $lang{ERROR}, "No required params");
    }
    else {
      my $first_commutation_id = $Tracer->get_commutation_for_equipment($FORM{NAS_ID});

      if ( !$first_commutation_id ) {
        $html->message('err', $lang{ERROR}, "Equipment $FORM{NAS_ID} is not present on any commutation");
      }
      else {
        my $path = $Tracer->get_path_beetween_nases($FORM{NAS_ID}, $FORM{ENDPOINT_NAS_ID});
        _error_show($Tracer);
        
        my $fiber_views = _cablecat_get_conection_path_view($path);
        if (!$fiber_views){
          $html->message('err', $lang{ERROR}, "Can't display commutation_path");
        }
        else {
          $TEMPLATE_PARAMS{PATH_VIEW} = $fiber_views;
        }
      }
    }
  }

  # Choose end point
  if ( $FORM{get_nases} ) {
    my $nases_list = $Equipment->_list({
      NAS_NAME  => '_SHOW',
      COLS_NAME => 1,
      PAGE_ROWS => 10000
    });

    if ($FORM{as_option}){
      print map { "<option value='$_->{nas_id}'>$_->{nas_name}</option>" } @$nases_list;
    }

    exit 0;
  }
  elsif ( $FORM{get_endpoints} && $FORM{NAS_ID} ) {
    my $uplinks = $Tracer->get_uplink_chain_for($FORM{NAS_ID});

    if ($FORM{as_option}){
      print map { "<option value='$_->{nas_id}'>$_->{nas_name}</option>" } @$uplinks;
    }

    exit 0;
  }

  my $given_nas_id = $FORM{ENDPOINT_NAS_ID};
  my $given_nas_list = [];

  my $search_form = $html->tpl_show(_include('cablecat_nas_trace_connection_form', 'Cablecat'),
    {
      NAS_ID_SELECT     => $html->form_select('NAS_ID', {
        SELECTED    => $given_nas_id,
        SEL_LIST    => $given_nas_list,
        SEL_VALUE   => 'nas_name',
        SEL_KEY     => 'nas_id',
        SEL_OPTIONS => (!$given_nas_id && $given_nas_list && scalar(@{$given_nas_list} > 1))
                          ? { '' => '' }
                          : undef,
        NORMAL_WIDTH => 1,
      }),

      END_NAS_ID_SELECT => $html->form_select('ENDPOINT_NAS_ID', {
        SELECTED     => $FORM{ENDPOINT_NAS_ID} || '',
        SEL_HASH     => $FORM{ENDPOINT_NAS_ID} ? { $FORM{ENDPOINT_NAS_ID} => 'Loading...' } : {},
        NORMAL_WIDTH => 1
      }),

      %TEMPLATE_PARAMS
    }, { OUTPUT2RETURN => 1 }
  );

  print $html->form_main({
    class   => 'form form-inline well well-sm',
    CONTENT => $search_form,
    HIDDEN => {
      index => $index,
    }
  });

  return 1;
}

#**********************************************************
=head2 cablecat_user_trace_connection_form()

=cut
#**********************************************************
sub cablecat_user_trace_connection_form {
  
  if ( my $module_load_error = load_pmodule("JSON", { SHOW_RETURN => 1 }) ) {
    print $module_load_error;
    return 0;
  }
  
  my Cablecat::Trace $Tracer = Cablecat::Trace->new($db, $admin, \%conf);
  my %TEMPLATE_PARAMS = ();
  
  
  my $uid = $FORM{UID} || 0;
  my $module_service_id_str = $FORM{USER_SERVICE} || '';
  my ($module, $service_id) = split(':', $module_service_id_str);
  
  # Helper to break from if
  my $return_with_error = sub {
    my ($text, $url, $id) = @_;
    $url //= "?index=$index";
    my $message = $html->message('err', $lang{ERROR}, $text, { OUTPUT2RETURN => 1, ID => $id });
    print $message;
#    $html->redirect($url, { MESSAGE => $message });
    use Abills::Base qw/_bp/;
    _bp("Called by", [ caller ], {HEADER => 0, EXIT => 0, TO_CONSOLE => 0});
    exit 0;
  };
  
  if ( $FORM{action} ) {
  
    if ( !$uid ) {
      # message about no uid
      $return_with_error->("$lang{REQUIRED_ARG} : UID");
    }
    elsif ( !$service_id ) {
      $return_with_error->("$lang{REQUIRED_ARG} : USER_SERVICE");
    }
    
    my $user_start_link = $Tracer->get_commutation_for_user($uid, $service_id, { RETURN_LINK => 1});
    _error_show($Tracer);
    _error_show($Cablecat);
    
    if (!$user_start_link){
      $html->message('err', $lang{ERROR}, "User is not present on commutation", { ID => 2210 });
      return 0;
    }
    
    my $nas_port ||= $Tracer->get_nas_port_for_service($uid, $service_id);
    if ( !$nas_port ) {
      _error_show($Tracer);
      $return_with_error->($Tracer->{errstr}, undef, $Tracer->{errno});
    }
    
    # Get start commutation for nas_port
    my $equipment_commutation_ids = $Tracer->get_commutation_for_equipment($nas_port->{nas_id}, $nas_port->{port},
      { WITH_TYPE => 1 }
    );
    
    if ( !$equipment_commutation_ids || !ref $equipment_commutation_ids eq 'ARRAY' ) {
      # Show message about no commutation
      _error_show($Tracer);
      $return_with_error->($Tracer->{errstr}, undef, $Tracer->{errno});
    }
    elsif ( !scalar(@{$equipment_commutation_ids}) ) {
      $return_with_error->("Can't find commutation for equipment $nas_port->{nas_id} port $nas_port->{port}", undef, $Tracer->{errno});
    }
    elsif (scalar @$equipment_commutation_ids > 1){
      $return_with_error->("Equipment is linked on more than one commutation", undef, 2201);
    }
    
    # Build trace
    my $path = $Tracer->get_path_beetween({
      TYPE      => 'UID',
      ID        => $uid,
      FIBER_NUM => $service_id
    },
      $equipment_commutation_ids->[0]
    );
    
    my $fiber_views = _cablecat_get_conection_path_view($path);
    if (!$fiber_views){
      $html->message('err', $lang{ERROR}, "Can't display commutation_path");
    }
    else {
      $TEMPLATE_PARAMS{PATH_VIEW} = $fiber_views;
    }
    
    # Show trace
  }
  
  # user_modal_search() can return numeric value when modlas is loaded
  my $user_modal_search_button = user_modal_search();
  if ( $user_modal_search_button && $user_modal_search_button eq 2 ) {
    return 1;
  }
  
  my @allowed_to_trace_services = ();
  if ( $uid ) {
    $TEMPLATE_PARAMS{USER_LOGIN} = $users->{LOGIN} || '';
    
    # Get list of user services
    my $user_services_search_list = $Tracer->get_user_nas_port_services($uid);
    _error_show($Tracer);
    
    if (!$user_services_search_list || !ref($user_services_search_list) eq 'ARRAY' ){
      $return_with_error->("Can't get user service list");
    }
    
    my @user_connections = @$user_services_search_list;
    
    # Look which nas_id are on commutation scheme
    foreach my $service_port ( @user_connections ) {
      next unless ( $service_port->{NAS_ID} );
      my $c_id = $Tracer->get_commutation_for_equipment($service_port->{NAS_ID}, $service_port->{PORT});
      next unless ( $c_id );
      $service_port->{COMMUTATION_ID} = $c_id;
      push(@allowed_to_trace_services, $service_port);
    }
  }
  
  $TEMPLATE_PARAMS{USER_SELECT} = $html->form_input('USER_LOGIN', $TEMPLATE_PARAMS{USER_LOGIN} || '', {
      TYPE     => 'text',
      DISABLED => 1
    });
  $TEMPLATE_PARAMS{SEARCH_BTN} = $user_modal_search_button;

  if (!$uid){

  }
  elsif (scalar @allowed_to_trace_services){
    $TEMPLATE_PARAMS{USER_SERVICE_SELECT} = _cablecat_get_user_services_select($uid, { WITH_MODULE => 1 });
  }
  else {
    $html->message('warn', $lang{ERROR}, "No service ports to trace");
  }
  
  my $search_form = $html->tpl_show(_include('cablecat_user_trace_connection_form', 'Cablecat'),
    \%TEMPLATE_PARAMS,
    { OUTPUT2RETURN => 1 }
  );
  
  print $html->form_main({
    class   => 'form form-inline well well-sm',
    CONTENT => $search_form,
    HIDDEN  => {
      index => $index,
      UID   => $uid || ''
    }
  });
  
  return 1;
}

#**********************************************************
=head2 cablecat_links_check()

=cut
#**********************************************************
sub cablecat_links_check {
  
  if ($FORM{del} && $FORM{COMMENTS}){
    $Cablecat->cablecat_links_del($FORM{del});
    show_result($Cablecat, $lang{DELETED});
  }
  
  # Get all links
  my $links = $Cablecat->links_list({
    SHOW_ALL_COLUMNS => 1,
    PAGE_ROWS        => 100000,
  });
  
  # Build a hash by commutation_id
  my %links_by_commutation_id = ();
  my @bad_links = ();
  
  foreach my $link ( @{$links} ) {
    my $fiber_1_key = join('_', $link->{element_1_type}, $link->{element_1_id}, $link->{fiber_num_1});
    my $fiber_2_key = join('_', $link->{element_2_type}, $link->{element_2_id}, $link->{fiber_num_2});
    
    $links_by_commutation_id{$link->{commutation_id}} //= {};
    my $com_hash = $links_by_commutation_id{$link->{commutation_id}};
    
    # If fiber is presented more than once at single commutation, add it to wrong links table
    my $has_bad_link = 0;
    if ( exists $com_hash->{$fiber_1_key} ) {
      push (@bad_links, $link, $com_hash->{$fiber_1_key});
      $has_bad_link = 1;
    }
    if ( exists $com_hash->{$fiber_2_key} ) {
      push (@bad_links, $link, $com_hash->{$fiber_2_key});
      $has_bad_link = 1;
    }
    
    next if ( $has_bad_link );
    
    $com_hash->{$fiber_1_key} = $link;
    $com_hash->{$fiber_2_key} = $link;
  }
  
  my Abills::HTML $table = $html->table({
    caption     => "Cablecat $lang{WRONG_LINKS}",
    DATA_TABLE  => 1,
    ID          => 'CABLECAT_WRONG_LINK',
    title_plain => [ '#', $lang{COMMUTATION}, 'Element 1', "$lang{FIBER} 1", 'Element 2', "$lang{FIBER} 2", '-' ],
  });
  
  my $commutation_index = get_function_index('cablecat_commutation');
  foreach my $bad_link ( @bad_links ) {
    my $commutation_btn = $html->button(
      "$lang{COMMUTATION}#$bad_link->{commutation_id}",
      "index=$commutation_index&ID=$bad_link->{commutation_id}"
    );
    
    my $del_button = $html->button('', "index=$index&del=$bad_link->{id}", {
        class   => 'btn btn-danger btn-xs',
        ICON    => 'glyphicon glyphicon-remove',
        CONFIRM => "$lang{DEL}?",
      });
    
    $table->addrow(
      $bad_link->{id},
      $commutation_btn,
      join('_', $bad_link->{element_1_type}, $bad_link->{element_1_id}),
      $bad_link->{fiber_num_1},
      join('_', $bad_link->{element_2_type}, $bad_link->{element_2_id}),
      $bad_link->{fiber_num_2},
      $del_button,
    );
  }
  
  print $table->show();
  
  return 1;
}

#**********************************************************
=head2 _cablecat_get_conection_path_view($path)

=cut
#**********************************************************
sub _cablecat_get_conection_path_view {
  my ($path) = @_;
  return 0 if (!$path || ref $path ne 'ARRAY');
  
  my %visualization_dispatch = (
    CABLE => sub {
      my ($cable_id, $fiber_num) = @_;
      my $cable_info = $Cablecat->cables_info($cable_id);
      _error_show($Cablecat) and return 0;
      my $btn = function_button($cable_info->{name}, 'cablecat_cables', $cable_id);
      return  "$btn  : $lang{FIBER} #" . $fiber_num;
    },
    EQUIPMENT => sub {
      my ($equipment_id, $fiber_num) = @_;
      my $equipment_info = $Equipment->_info($equipment_id);
      _error_show($Equipment) and return 0;
      my $btn = function_button(
        ($equipment_info->{SYSTEM_ID} || $lang{EQUIPMENT}) . ' #' . $equipment_id,
        'equipment_info', $equipment_id
      );
      return "$btn $lang{PORT}#" . $fiber_num;
    },
    CROSS    => sub {
      my ($cross_id, $port_num) = @_;
      my $cross_info = $Cablecat->crosses_info($cross_id);
      _error_show($Cablecat) and return 0;
      my $cross_link = $Cablecat->cross_links_info(undef, { CROSS_ID => $cross_id, CROSS_PORT => $port_num });
      _error_show($Cablecat) and return 0;
      
      my $btn = function_button("$lang{CROSS} $cross_info->{name}", 'cablecat_crosses', $cross_id);
      my $link_info = _cablecat_cross_link_info($cross_link, $port_num, $cross_id, { CROSS_INFO => $cross_info });
      
      return "$btn. $lang{PORT} : $port_num -> $link_info";
    },
    UID     => sub {
      my ($client_id, $service_id) = @_;
      my $users_list = $users->list({ UID => $client_id, COLS_NAME => 1, PAGE_ROWS => 1 });
      _error_show($users);
      my $user = $users_list->[0] || 0;
      my $login = $user->{login} || '';
      
      return "$lang{USER} - " . user_ext_menu($client_id, $login) . " $lang{SERVICE}#$service_id";
    },
    COMMUTATION => sub {
      my ($commutation_id) = @_;
      return _cablecat_commutation_info_table($commutation_id);
    },
    SPLITTER => sub {
      my ($splitter_id, $fiber_num) = @_;
      return function_button(
        $lang{SPLITTER} . "#$splitter_id",
        'cablecat_splitters',
        $splitter_id
      ) . " - $lang{FIBER}#$fiber_num";
    },
    DEFAULT => sub {
      #            my ($element_type, $element_id, $fiber_num) = @_;
      return join (' - ', @_);
    }
  );
  
  my @before_commutation_views = ();
  my @commutation_order = ();
  my %path_for_commutation = ();
  
  foreach my $connection (@$path){
    my $vis_sub = $visualization_dispatch{$connection->{element_type}};
    my $commutation_id = 0;
    if ($connection->{commutation_id}){
      $commutation_id = $connection->{commutation_id};
      my $prev_comm = $commutation_order[$#commutation_order];
      if (!$prev_comm || $prev_comm != $commutation_id){
        push(@commutation_order, $commutation_id)
      }
    };
    
    my $view = '';
    if ($vis_sub){
      $view .= $vis_sub->($connection->{element_id}, $connection->{fiber_num});
    }
    else {
      $view .= $visualization_dispatch{DEFAULT}->(
        $connection->{element_type},
        $connection->{element_id},
        $connection->{fiber_num}
      );
    }
    
    if (!$commutation_id){
      push (@before_commutation_views, $view);
      next;
    }
    elsif (exists $path_for_commutation{$commutation_id}){
      push (@{$path_for_commutation{$commutation_id}}, $view);
    }
    else{
      $path_for_commutation{$commutation_id} = [ $view ];
    }
  }
  
  # First adding path before commutation
  
  my $without_commutation = join($html->br, map { $html->element('span', $_) } @before_commutation_views) . $html->br;
  # Then show commutations one by one
  my $commutations_view = '';
  foreach my $commutation_id (@commutation_order){
    my @views = @{$path_for_commutation{$commutation_id}};
    
    $commutations_view .= $visualization_dispatch{COMMUTATION}->($commutation_id);
    
    my @views_list = map {
      $html->element('span', $_, { class => 'list-group-item' });
    } @views;
    
    $commutations_view .= $html->element('div', join('', @views_list), {class => 'list-group' })
  }
  
  return $html->tpl_show(_include('cablecat_commutation_path_view', 'Cablecat'),{
    WITHOUT_COMMUTATION => $without_commutation,
      COMMUTATIONS_LIST => $commutations_view
  },{ OUTPUT2RETURN => 1 });
}


#**********************************************************
=head2 _cablecat_break_cable_in_two_parts()

=cut
#**********************************************************
sub _cablecat_break_cable_in_two_parts {
  my ($break_cable_id, $inserted_well_id) = @_;
  return unless ( $break_cable_id );
  
  # Get polyline_id
  my $cable_list = $Cablecat->cables_list({ ID => $break_cable_id, POLYLINE_ID => '_SHOW' });
  return 0 unless ($cable_list && ref $cable_list eq 'ARRAY' && scalar (@$cable_list));
  my $polyline_id = $cable_list->[0]{polyline_id};
  
  # Insert well, breaks cable
  my $add_result = $Cablecat->break_cable($break_cable_id, $inserted_well_id);
  if ( !$add_result || ref $add_result ne 'ARRAY' ) {
    _error_show($Cablecat);
    return qq{Can\'t insert well : $add_result };
  };
  
  my ( undef, $cable_id_1, $cable_id_2 ) = @{$add_result};
  
  # Should also break polyline for this cables
  my $break_result = $Maps->break_polyline(
    $polyline_id,
    {
      COORDX => $FORM{COORDX},
      COORDY => $FORM{COORDY}
    }
  );
  
  if ( !$break_result || ref $break_result ne 'ARRAY' ) {
    _error_show($Maps);
    return qq{Can\'t break polyline : $break_result }
  };
  
  my ($new_object1_id, $new_object2_id ) = @{$break_result};
  
  # Update cables info
  #FIXME: check object adding order
  $Cablecat->cables_change({ ID => $cable_id_1, POINT_ID => $new_object2_id });
  $Cablecat->cables_change({ ID => $cable_id_2, POINT_ID => $new_object1_id });
  
  return 1;
}

#**********************************************************
=head2 _cablecat_get_link_info($element_type, $element_id, $fiber_num, $direction, $info)

=cut
#**********************************************************
sub _cablecat_get_link_info {
  my ($element_type, $element_id, $fiber_num, $direction, $info) = @_;
  
  if ( !$info ) {
    my $list = $Cablecat->links_for_element_list($element_type, $element_id, {
        FIBER_NUM_1      => $fiber_num,
        DIRECTION        => $direction || '0',
        SHOW_ALL_COLUMNS => 1,
        PAGE_ROWS        => 1
      });
    _error_show($Cablecat);
    
    $info = $list->[0];
  }
  
  my $other_element_type = $info->{element_2_type};
  my $other_element_id = $info->{element_2_id};
  my $other_element_fiber_in = $info->{fiber_num_2};
  
  return unless ($other_element_type && $other_element_id && $other_element_fiber_in);
  
  # get another linked element
  if ( $other_element_type eq 'CABLE' ) {
    #      my $opposite_element = Cablecat::Trace::_get_another_element_for_link($info, 'CABLE', $cable_id, $f_num );
    
    my $commutation_btn = $html->button(
      $lang{COMMUTATION} . '#' . $info->{commutation_id},
      'get_index=cablecat_commutation&full=1&ID=' . $info->{commutation_id}
    );
    
    my $cable_btn = _cablecat_get_cable_button($other_element_id);
    
    my $att_info = ($info->{attenuation})
      ? "$lang{ATTENUATION} :  $info->{attenuation}"
      : '';
  
    my $comm = ($info->{comments})
      ? "$lang{COMMENTS} :  $info->{comments}"
      : '';
    
    my $res = join($html->br,
      "$cable_btn : $lang{FIBER}# " . $html->b($other_element_fiber_in),
      $commutation_btn,
      $att_info,
      $comm
    );
    
    return $res;
  }
  if ( $other_element_type eq 'UID' ) {
    my $user_info = $users->info($other_element_id);
    return user_ext_menu($user_info->{UID}, $user_info->{LOGIN});
  }
  elsif ( $other_element_type eq 'EQUIPMENT' ) {
    my $equipment_info = $Equipment->_info($other_element_id);
    # TODO: link
    return $html->b($equipment_info->{SYSTEM_ID} || $equipment_info->{NAS_NAME} || $lang{EQUIPMENT})
      . ' : ' . ($other_element_fiber_in || q{});
  }
  elsif ( $other_element_type eq 'SPLITTER' ) {
    my $splitter = $Cablecat->splitters_info($other_element_id);
    return function_button("$lang{SPLITTER} " . $html->b("$splitter->{TYPE}#$splitter->{ID}"), 'cablecat_splitters', $other_element_id)
     . ' : ' . ($other_element_fiber_in || q{});
  }
  elsif ( $other_element_type eq 'POINT' ) {
    my $object = $Maps->points_info($other_element_id);
    my $type = _translate($object->{TYPE});
    
    return "$lang{OBJECT} : $object->{NAME}($lang{TYPE} : $type)";
  }
  elsif ( $other_element_type eq 'CROSS' ) {
    my $cross = $Cablecat->crosses_info($other_element_id, {
        COLS_UPPER       => 0,
        SHOW_ALL_COLUMNS => 0,
        NAME             => '_SHOW',
      });
    
    my $cross_link = function_button($cross->{name}, 'cablecat_crosses', $cross->{id});
    return "$lang{CROSS} : $cross_link#$other_element_fiber_in";
  }
  
  return '';
}

#**********************************************************
=head2 _cablecat_link_info_cell($element_type, $element_id, $fiber_num, $direction, $html)

=cut
#**********************************************************
sub _cablecat_link_info_cell {
  my ($element_type, $element_id, $fiber_num, $direction, $data) = @_;
  
  $direction ||= 0;
  
  if ( !$data ) {
    return $html->button('', '', {
        class     => 'add',
        ICON      => 'glyphicon glyphicon-plus',
        BUTTON    => 1,
        SKIP_HREF => 1,
        ex_params => "onClick='addLinkInfo(\"$element_type\", $element_id, $fiber_num, $direction)'"
      })
  }
  
  my $del_btn = $html->button('', '', {
      class     => 'btn btn-xs btn-danger',
      ICON      => 'glyphicon glyphicon-remove',
      SKIP_HREF => 1,
      ex_params => "onClick='clearLinkInfo(\"$element_type\", $element_id, $fiber_num, $direction)'"
    });
  
  return $html->element('div', $data, { class => 'col-xs-10' })
    . $html->element('div', $del_btn, { class => 'col-xs-2' });
  
}


#**********************************************************
=head2 _cablecat_get_cable_button()

=cut
#**********************************************************
sub _cablecat_get_cable_button {
  my ($cable_id, $attr) = @_;
  state $cables_info = {};
  
  return '' unless ( $cable_id );
  
  if ( !exists $cables_info->{$cable_id} ) {
    
    if ( $attr->{NAME} ) {
      $cables_info->{$cable_id}->{name} = $attr->{NAME};
    }
    else {
      $cables_info->{$cable_id} = $Cablecat->cables_info($cable_id);
      _error_show($Cablecat);
    }
    
  }
  
  my $info = $cables_info->{$cable_id};
  
  return $html->button($info->{name}, 'get_index=cablecat_cables&full=1&chg=' . $cable_id);
}

#**********************************************************
=head2 _cablecat_address_for_well_id()

=cut
#**********************************************************
sub _cablecat_address_for_well_id {
  my ($well_id) = @_;
  
  my $well_info = $Cablecat->wells_info($well_id);
  if ( $well_info->{point_id} ) {
    my $point_info = $Maps->points_info($well_info->{point_id}, { ADDRESS_FULL => '_SHOW', COLS_UPPER => 0 });
    
    my $map_btn = _cablecat_result_former_point_id_filter($well_info->{point_id},
      { PARAMS => [ $MAP_LAYER_ID{WELL} ] });
    my $address = $point_info->{address_full} || '';
    
    return  $address . ' ' . $map_btn;
  }
  
  #TODO: show 'edit/set' button
  
  return '';
}

#**********************************************************
=head2 _cablecat_cable_length($cable_id)

  Arguments:
    $cable_id,
    
  Returns:
     length in meters
=cut
#**********************************************************
sub _cablecat_cable_length {
  
  my ($cable_id) = @_;
  
  my $cable = $Cablecat->cables_info($cable_id);
  my $polyline_id = $cable->{polyline_id};
  return 0 unless ( $cable->{polyline_id} );
  
  my $points_list = $Maps->polyline_points_list({
    POLYLINE_ID => $polyline_id,
    COORDX      => '_SHOW',
    COORDY      => '_SHOW',
  });
  _error_show($Maps);
  
  my @points = @{$points_list};
  
  my $i = 0;
  my $cable_length = 0;
  while ( $i++ < $#points ) {
    $cable_length += Maps::_mercator_to_meters($points[$i]->{COORDX}, $points[$i]->{COORDY},
      $points[$i - 1]->{COORDX}, $points[$i - 1]->{COORDY});
  }
  
  return $cable_length;
}

#**********************************************************
=head2 _cablecat_get_user_services_select($uid, $attr)

  Arguments:
    $uid
    $attr
      RETURN_LIST - returns formatted services list
      WITH_MODULE - will add module name to select option value "$module_name:$_->{id}"
      
  Returns:
    string html
  
=cut
#**********************************************************
sub _cablecat_get_user_services_select {
  my ($uid, $attr) = @_;
  
  # Should show user services select
  my $Tracer = Cablecat::Trace->new($db, $admin, \%conf);
  
  my ($services, $module_name ) = $Tracer->get_user_services($uid, { NAS_NAME => '_SHOW' });
  
  return 0 if ($Tracer->{errno} || !$services || ref $services ne 'ARRAY');
  
  # Should pass more than one value in select value
  my @select_options = map {{
    id   => $attr->{WITH_MODULE} ? "$module_name:$_->{id}" : $_->{id},
    name => " $module_name: ($_->{nas_name}#$_->{nas_id}) : $lang{PORT} #$_->{port}"
  }} @$services;
  
  return \@select_options if ($attr->{RETURN_LIST});
  
  return  make_select_from_list('USER_SERVICE', \@select_options);
}

1;
